# 第二章

## 海象的迷

### LIST

在java中数组的大小是确定的。

```java
Walrus a = new Walrus(1000, 8.3);
Walrus b;
b = a;
b.weight = 5;
System.out.println(a);
System.out.println(b);
```

其中，a,b是相同的，因为a和b都是指向同一个对象实例，所以当b进行修改时，那个对象实例也在被修改。

### 字节

电脑中的所有信息都是用0和1来存储，不同值有不同的表示；

但有趣的一点是72和H都是用01001000来存储，那么`java`是如何分辨的呢？
答案是类型

JAVA解释器会根据类型的不同来诠释不同的意思。
JAVA初始有8个类型： byte, short, int, long, float, double, boolean, 和 char.

### reference type

除了上述的8个基本类型外，其他类型包括`arrays`都是`reference type`。

当我们使用`new`来实例化一个物体时，java对每个实例分配空间，再用默认值来装填。

### Reference Variable Declaration

当我们声明一个参考类型的变量时，java总是分配64bits的空间，不论参考类型是什么。
这个问题可以通过以下信息轻松解决：64位空间中不包含有关海象的数据，而是包含海象在内存中的地址。

```java
Walrus someWalrus;
someWalrus = new Walrus(1000, 8.3);
```

其中，第一行是声明变量名，使用了64bits空间，而第二行相当于是`new`返回一个地址值，指向新创建的Walrus。

### 参数传递

在将参数传递给函数时，也是在传输这些bits，在一个函数里有自己的作用域。

### 数组的实例化

存储数组的变量是引用变量，就像其他变量一样。作为示例，请考虑以下声明：

```java
int[] x;
Planet[] planets;
```

这两个声明都会创建 64 位内存盒。`x`只能保存数组的地址`int`，`planets`也只能保存数组的地址`Planet`。

实例化数组与实例化对象非常相似。例如，如果我们创建一个大小为 5 的整数数组，如下所示：

```java
x = new int[]{0, 1, 2, 95, 4};
```

然后该`new`关键字创建 5 个每个 32 位的框，并返回整个对象的地址以分配给 x。

如果丢失与地址对应的位，则对象可能会丢失。例如，如果特定海象地址的唯一副本存储在 中`x`，那么`x = null`将导致您永久丢失该海象。这不一定是坏事，因为您经常会决定已经完成了一个对象，因此简单地丢弃引用是安全的。当我们在本章后面构建列表时，我们将看到这一点。

### 大小和迭代大小

学会自己写一个`size()`和`iterativeSize`，其中第一个应该使用递归，而第二个用迭代。

```java
/** Return the size of the list using... recursion! */
public int size() {
    if (rest == null) {
        return 1;
    } //当没有下一个，即是最后一个时，返回1
    return 1 + this.rest.size();
}
```

递归是将复杂情况分为两类，一类是简单情况，另一类是下一级，如此递归

```java
/** Return the size of the list using no recursion! */
public int iterativeSize() {
    IntList p = this; //使用p来代替this，因为我不能再次声明分配this
    int totalSize = 0;
    while (p != null) {
        totalSize += 1;
        p = p.rest;
    }
    return totalSize;
}
```

迭代是将地址指针指向下一个

```java
	/** Returns the ith item of this IntList. */
	public int get(int i) {
		if (i == 0) {
			return first;
		}
		return rest.get(i - 1);
	}

	public static void main(String[] args) {
		IntList L = new IntList(15, null);
		L = new IntList(10, L);
		L = new IntList(5, L);

		System.out.println(L.get(100));
	}
```

这些都是有关于构造链表的，从构造到统计大小，返回值。

## 关于IDEA

### 调试

在赋予断点后，有多种前进方式，

`step into`是一步一步进行；

`step over`是直接执行一个函数，而不去看里面的细节

`step out`是退出当前调试的函数

`resume`它用于继续执行程序，直到下一个断点或程序完成执行。具体来说，"Resume" 用于在调试模式下暂停的情况下继续执行程序

## 破坏性代码和非破坏性代码

所谓破坏性是指原来的变量也发生了变化，而非破坏性是指原来的值并未变化，且返回了想要的函数效果。

## SLList

前面我们构造了`IntList`这个数据结构，但在实际中这个数据结构是比较难用的，难以阅读和维护。从根本上来说，问题在于`IntList`我所说的**裸递归**数据结构。

因此，这次我们构造`SLList`数据结构：

```java
public class IntNode {
    //整数节点
    public int item;
    public IntNode next;

    public IntNode(int i, IntNode n) {
        item = i;
        next = n;
    }
}
```

`IntNodes`很难使用，我们将创建一个名为`SLList`用户将与之交互的单独的类。基本类很简单：

```java
public class SLList {
    public IntNode first;

    public SLList(int x) {
        first = new IntNode(x, null);
    }
}
```

在使用上的区别：

```java
IntList L1 = new IntList(5, null);
SLList L2  = new SLList(5);
```

可见使用`SLList`时会比较简单，仅需要一个整数就可以定义。现在`SLList`还不是特别有用，后面再添加`addFirst`和`getFirst`等方法。

### addFirst and getFirst

```java
public class SLList {
    public IntNode first;

    public SLList(int x) {
        first = new IntNode(x, null);
    }

    /** Adds an item to the front of the list. */
    public void addFirst(int x) {
        first = new IntNode(x, first);
    }
    /** Retrieves the front item from the list. */
    public int getFirst() {
        return first.item;
    }
}
```

### Public vs. Private

不幸的是，我们`SLList`可以被绕过，我们的裸数据结构的原始力量（及其所有危险）可以被访问。程序员可以轻松地直接修改列表，而无需通过经过孩子测试、母亲认可的`addFirst`方法，例如：

```java
SLList L = new SLList(15);
L.addFirst(10);
L.first.next.next = L.first.next;//使用了IntList的结构，且形成了循环
```

这会导致出现无限循环的格式错误的列表。为了解决这个问题，我们可以修改`SLList`类，以便`first`使用关键字声明变量`private`。

```java
public class SLList {
    private IntNode first; //使first只能在SLList内被访问使用
...
```

私有变量和方法只能由同一文件内的代码访问`.java`，例如在本例中`SLList.java`。这意味着像下面这样的类`SLLTroubleMaker`将无法编译，并产生`first has private access in SLList`错误。

```java
public class SLLTroubleMaker {
    public static void main(String[] args) {
        SLList L = new SLList(15);
        L.addFirst(10);
        L.first.next.next = L.first.next;
    }
}
```

相比之下，`SLList.java`文件内的任何代码都可以访问该`first`变量。

限制访问可能看起来有点愚蠢。毕竟，`private`关键字所做的唯一事情就是破坏原本可以编译的程序。然而，在大型软件工程项目中，`private`关键字是一个宝贵的信号，表明最终用户应该忽略（因此不需要理解）某些代码片段。同样，`public`关键字应该被视为一种声明，表明方法可用并且将**永远**像现在一样工作。

### Nested Classes

这时我们已经有两个Java文件了，但`IntNode`仅仅是`SLList`的一个支持。
针对这种情况，Java 为我们提供了将类声明嵌入到另一个类声明中的能力。语法简单直观：

```java
public class SLList {
    	//内嵌的模板
       public static class IntNode {
            public int item;
            public IntNode next;
            public IntNode(int i, IntNode n) {
                item = i;
                next = n;
            }
       }
    	
       private IntNode first; 

       public SLList(int x) {
           first = new IntNode(x, null);
       } 
...
```

在加上`static`后

意味着静态类中的方法不能访问封闭类的任何成员。在这种情况下，这意味着 中`IntNode`的任何方法都无法访问`first`、`addFirst`或`getFirst`。

### addLast() and size()

补充下面类。

```java
public class SLList {
    public class IntNode {
        public int item;
        public IntNode next;
        public IntNode(int i, IntNode n) {
            item = i;
            next = n;
        }
    }

    private IntNode first; 

    public SLList(int x) {
        first = new IntNode(x, null);
    }

    /** Adds an item to the front of the list. */
    public void addFirst(int x) {
        first = new IntNode(x, first);
    }    

    /** Retrieves the front item from the list. */
    public int getFirst() {
        return first.item;
    }

    /** Adds an item to the end of the list. */
    public void addLast(int x) {
        /* Your Code Here! */
        IntNode p = first;
        while (p.next != null) {
            p = p.next;
        }
        first.next = new SLList(x);
    }

    /** Returns the number of items in the list using recursion. */
    public int size() {
        /* Your Code Here! */
        return size(first);
    }
    
    private static int size(IntNode p) {
        if (p.next == null) {
            return 1;
        }

        return 1 + size(p.next);
    }
    //创建了一个static的method
        
}
```

这样就有两个`size`函数了，但在Java中是被允许的，因为他们的参数不一样，这样称为**重载**，在C++中也是常见的。

### Caching

