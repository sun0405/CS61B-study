# 第二章

## 海象的迷

### LIST

在java中数组的大小是确定的。

```java
Walrus a = new Walrus(1000, 8.3);
Walrus b;
b = a;
b.weight = 5;
System.out.println(a);
System.out.println(b);
```

其中，a,b是相同的，因为a和b都是指向同一个对象实例，所以当b进行修改时，那个对象实例也在被修改。

### 字节

电脑中的所有信息都是用0和1来存储，不同值有不同的表示；

但有趣的一点是72和H都是用01001000来存储，那么`java`是如何分辨的呢？
答案是类型

JAVA解释器会根据类型的不同来诠释不同的意思。
JAVA初始有8个类型： byte, short, int, long, float, double, boolean, 和 char.

### reference type

除了上述的8个基本类型外，其他类型包括`arrays`都是`reference type`。

当我们使用`new`来实例化一个物体时，java对每个实例分配空间，再用默认值来装填。

### Reference Variable Declaration

当我们声明一个参考类型的变量时，java总是分配64bits的空间，不论参考类型是什么。
这个问题可以通过以下信息轻松解决：64位空间中不包含有关海象的数据，而是包含海象在内存中的地址。

```java
Walrus someWalrus;
someWalrus = new Walrus(1000, 8.3);
```

其中，第一行是声明变量名，使用了64bits空间，而第二行相当于是`new`返回一个地址值，指向新创建的Walrus。

### 参数传递

在将参数传递给函数时，也是在传输这些bits，在一个函数里有自己的作用域。

### 数组的实例化

存储数组的变量是引用变量，就像其他变量一样。作为示例，请考虑以下声明：

```java
int[] x;
Planet[] planets;
```

这两个声明都会创建 64 位内存盒。`x`只能保存数组的地址`int`，`planets`也只能保存数组的地址`Planet`。

实例化数组与实例化对象非常相似。例如，如果我们创建一个大小为 5 的整数数组，如下所示：

```java
x = new int[]{0, 1, 2, 95, 4};
```

然后该`new`关键字创建 5 个每个 32 位的框，并返回整个对象的地址以分配给 x。

如果丢失与地址对应的位，则对象可能会丢失。例如，如果特定海象地址的唯一副本存储在 中`x`，那么`x = null`将导致您永久丢失该海象。这不一定是坏事，因为您经常会决定已经完成了一个对象，因此简单地丢弃引用是安全的。当我们在本章后面构建列表时，我们将看到这一点。

### 大小和迭代大小

学会自己写一个`size()`和`iterativeSize`，其中第一个应该使用递归，而第二个用迭代。

```java
/** Return the size of the list using... recursion! */
public int size() {
    if (rest == null) {
        return 1;
    } //当没有下一个，即是最后一个时，返回1
    return 1 + this.rest.size();
}
```

递归是将复杂情况分为两类，一类是简单情况，另一类是下一级，如此递归

```java
/** Return the size of the list using no recursion! */
public int iterativeSize() {
    IntList p = this; //使用p来代替this，因为我不能再次声明分配this
    int totalSize = 0;
    while (p != null) {
        totalSize += 1;
        p = p.rest;
    }
    return totalSize;
}
```

迭代是将地址指针指向下一个

```java
	/** Returns the ith item of this IntList. */
	public int get(int i) {
		if (i == 0) {
			return first;
		}
		return rest.get(i - 1);
	}

	public static void main(String[] args) {
		IntList L = new IntList(15, null);
		L = new IntList(10, L);
		L = new IntList(5, L);

		System.out.println(L.get(100));
	}
```

这些都是有关于构造链表的，从构造到统计大小，返回值。

## 关于IDEA

### 调试

在赋予断点后，有多种前进方式，

`step into`是一步一步进行；

`step over`是直接执行一个函数，而不去看里面的细节

`step out`是退出当前调试的函数

`resume`它用于继续执行程序，直到下一个断点或程序完成执行。具体来说，"Resume" 用于在调试模式下暂停的情况下继续执行程序

## 破坏性代码和非破坏性代码

所谓破坏性是指原来的变量也发生了变化，而非破坏性是指原来的值并未变化，且返回了想要的函数效果。
