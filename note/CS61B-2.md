# 第二章

## 海象的迷

### LIST

在java中数组的大小是确定的。

```java
Walrus a = new Walrus(1000, 8.3);
Walrus b;
b = a;
b.weight = 5;
System.out.println(a);
System.out.println(b);
```

其中，a,b是相同的，因为a和b都是指向同一个对象实例，所以当b进行修改时，那个对象实例也在被修改。

### 字节

电脑中的所有信息都是用0和1来存储，不同值有不同的表示；

但有趣的一点是72和H都是用01001000来存储，那么`java`是如何分辨的呢？
答案是类型

JAVA解释器会根据类型的不同来诠释不同的意思。
JAVA初始有8个类型： byte, short, int, long, float, double, boolean, 和 char.

### reference type

除了上述的8个基本类型外，其他类型包括`arrays`都是`reference type`。

当我们使用`new`来实例化一个物体时，java对每个实例分配空间，再用默认值来装填。

### Reference Variable Declaration

当我们声明一个参考类型的变量时，java总是分配64bits的空间，不论参考类型是什么。
这个问题可以通过以下信息轻松解决：64位空间中不包含有关海象的数据，而是包含海象在内存中的地址。

```java
Walrus someWalrus;
someWalrus = new Walrus(1000, 8.3);
```

其中，第一行是声明变量名，使用了64bits空间，而第二行相当于是`new`返回一个地址值，指向新创建的Walrus。

### 参数传递

在将参数传递给函数时，也是在传输这些bits，在一个函数里有自己的作用域。

### 数组的实例化

存储数组的变量是引用变量，就像其他变量一样。作为示例，请考虑以下声明：

```java
int[] x;
Planet[] planets;
```

这两个声明都会创建 64 位内存盒。`x`只能保存数组的地址`int`，`planets`也只能保存数组的地址`Planet`。

实例化数组与实例化对象非常相似。例如，如果我们创建一个大小为 5 的整数数组，如下所示：

```java
x = new int[]{0, 1, 2, 95, 4};
```

然后该`new`关键字创建 5 个每个 32 位的框，并返回整个对象的地址以分配给 x。

如果丢失与地址对应的位，则对象可能会丢失。例如，如果特定海象地址的唯一副本存储在 中`x`，那么`x = null`将导致您永久丢失该海象。这不一定是坏事，因为您经常会决定已经完成了一个对象，因此简单地丢弃引用是安全的。当我们在本章后面构建列表时，我们将看到这一点。

### 大小和迭代大小

学会自己写一个`size()`和`iterativeSize`，其中第一个应该使用递归，而第二个用迭代。

```java
/** Return the size of the list using... recursion! */
public int size() {
    if (rest == null) {
        return 1;
    } //当没有下一个，即是最后一个时，返回1
    return 1 + this.rest.size();
}
```

递归是将复杂情况分为两类，一类是简单情况，另一类是下一级，如此递归

```java
/** Return the size of the list using no recursion! */
public int iterativeSize() {
    IntList p = this; //使用p来代替this，因为我不能再次声明分配this
    int totalSize = 0;
    while (p != null) {
        totalSize += 1;
        p = p.rest;
    }
    return totalSize;
}
```

迭代是将地址指针指向下一个

```java
	/** Returns the ith item of this IntList. */
	public int get(int i) {
		if (i == 0) {
			return first;
		}
		return rest.get(i - 1);
	}

	public static void main(String[] args) {
		IntList L = new IntList(15, null);
		L = new IntList(10, L);
		L = new IntList(5, L);

		System.out.println(L.get(100));
	}
```

这些都是有关于构造链表的，从构造到统计大小，返回值。

## 关于IDEA

### 调试

在赋予断点后，有多种前进方式，

`step into`是一步一步进行；

`step over`是直接执行一个函数，而不去看里面的细节

`step out`是退出当前调试的函数

`resume`它用于继续执行程序，直到下一个断点或程序完成执行。具体来说，"Resume" 用于在调试模式下暂停的情况下继续执行程序

## 破坏性代码和非破坏性代码

所谓破坏性是指原来的变量也发生了变化，而非破坏性是指原来的值并未变化，且返回了想要的函数效果。

## SLList（单链表）

前面我们构造了`IntList`这个数据结构，但在实际中这个数据结构是比较难用的，难以阅读和维护。从根本上来说，问题在于`IntList`我所说的**裸递归**数据结构。

因此，这次我们构造`SLList`数据结构：

```java
public class IntNode {
    //整数节点
    public int item;
    public IntNode next;

    public IntNode(int i, IntNode n) {
        item = i;
        next = n;
    }
}
```

`IntNodes`很难使用，我们将创建一个名为`SLList`用户将与之交互的单独的类。基本类很简单：

```java
public class SLList {
    public IntNode first;

    public SLList(int x) {
        first = new IntNode(x, null);
    }
}
```

在使用上的区别：

```java
IntList L1 = new IntList(5, null);
SLList L2  = new SLList(5);
```

可见使用`SLList`时会比较简单，仅需要一个整数就可以定义。现在`SLList`还不是特别有用，后面再添加`addFirst`和`getFirst`等方法。

### addFirst and getFirst

```java
public class SLList {
    public IntNode first;

    public SLList(int x) {
        first = new IntNode(x, null);
    }

    /** Adds an item to the front of the list. */
    public void addFirst(int x) {
        first = new IntNode(x, first);
    }
    /** Retrieves the front item from the list. */
    public int getFirst() {
        return first.item;
    }
}
```

### Public vs. Private

不幸的是，我们`SLList`可以被绕过，我们的裸数据结构的原始力量（及其所有危险）可以被访问。程序员可以轻松地直接修改列表，而无需通过经过孩子测试、母亲认可的`addFirst`方法，例如：

```java
SLList L = new SLList(15);
L.addFirst(10);
L.first.next.next = L.first.next;//使用了IntList的结构，且形成了循环
```

这会导致出现无限循环的格式错误的列表。为了解决这个问题，我们可以修改`SLList`类，以便`first`使用关键字声明变量`private`。

```java
public class SLList {
    private IntNode first; //使first只能在SLList内被访问使用
...
```

私有变量和方法只能由同一文件内的代码访问`.java`，例如在本例中`SLList.java`。这意味着像下面这样的类`SLLTroubleMaker`将无法编译，并产生`first has private access in SLList`错误。

```java
public class SLLTroubleMaker {
    public static void main(String[] args) {
        SLList L = new SLList(15);
        L.addFirst(10);
        L.first.next.next = L.first.next;
    }
}
```

相比之下，`SLList.java`文件内的任何代码都可以访问该`first`变量。

限制访问可能看起来有点愚蠢。毕竟，`private`关键字所做的唯一事情就是破坏原本可以编译的程序。然而，在大型软件工程项目中，`private`关键字是一个宝贵的信号，表明最终用户应该忽略（因此不需要理解）某些代码片段。同样，`public`关键字应该被视为一种声明，表明方法可用并且将**永远**像现在一样工作。

### Nested Classes

这时我们已经有两个Java文件了，但`IntNode`仅仅是`SLList`的一个支持。
针对这种情况，Java 为我们提供了将类声明嵌入到另一个类声明中的能力。语法简单直观：

```java
public class SLList {
    	//内嵌的模板
       public static class IntNode {
            public int item;
            public IntNode next;
            public IntNode(int i, IntNode n) {
                item = i;
                next = n;
            }
       }
    	
       private IntNode first; 

       public SLList(int x) {
           first = new IntNode(x, null);
       } 
...
```

在加上`static`后

意味着静态类中的方法不能访问封闭类的任何成员。在这种情况下，这意味着 中`IntNode`的任何方法都无法访问`first`、`addFirst`或`getFirst`。

### addLast() and size()

补充下面类。

```java
public class SLList {
    public class IntNode {
        public int item;
        public IntNode next;
        public IntNode(int i, IntNode n) {
            item = i;
            next = n;
        }
    }

    private IntNode first; 

    public SLList(int x) {
        first = new IntNode(x, null);
    }

    /** Adds an item to the front of the list. */
    public void addFirst(int x) {
        first = new IntNode(x, first);
    }    

    /** Retrieves the front item from the list. */
    public int getFirst() {
        return first.item;
    }

    /** Adds an item to the end of the list. */
    public void addLast(int x) {
        /* Your Code Here! */
        IntNode p = first;
        while (p.next != null) {
            p = p.next;
        }
        first.next = new SLList(x);
    }

    /** Returns the number of items in the list using recursion. */
    public int size() {
        /* Your Code Here! */
        return size(first);
    }
    
    private static int size(IntNode p) {
        if (p.next == null) {
            return 1;
        }

        return 1 + size(p.next);
    }
    //创建了一个static的method
        
}
```

这样就有两个`size`函数了，但在Java中是被允许的，因为他们的参数不一样，这样称为**重载**，在C++中也是常见的。

### Caching（缓存）

将`size`方法重写，使其性能变好。

```java
public class SLList {
    ... /* IntNode declaration omitted. */
    private IntNode first;
    private int size; //增加一个size变量

    public SLList(int x) {
        first = new IntNode(x, null);
        size = 1;//初始化时size为1
    }

    public void addFirst(int x) {
        first = new IntNode(x, first);
        size += 1;
    }

    public int size() {
        return size;
    }
    ...
}
```

即在SLList中添加Size变量，称其为缓存，用来记录数据结构的大小，这个可以使我们在统计大小时非常快。
当然，这个会降低`addFirst`的性能，同时增加类的内存，但是这个增量很小，在可接受范围内。

### The Empty List

前面我们已经说了`SLList`对比`IntList`有许多的优点。
另一个优点是`SLList`能够简单地生成一个空list，如下

```java
public Sllist() {
    first = null;
    size = 0;
}
```

但是`addlast`方法在插入空集时会报错，因为`first`是`null`，而函数中有`while (p.next != null)`。

### Sentinel Nodes(哨兵节点)

因为上述的`addLast`不能添加空节点，下面是对空节点做出的特殊处理：

```java
public void addLast (int x) {
    size += 1; //大小记得加一
    
    if (first == null) {
        fist = new IntNode(x, null); //直接引入新节点作为整个节点，因为前面是空节点
        return;
    }
    
    IntNode p = first;
    while (p != null ) {
        p = p.next;
    }
    
    p.next = new IntNode(x, null);
}
```

人类的工作记忆有限，因此我们希望尽可能控制复杂性。

一个更干净但不太明显的解决方案是使所有内容都“相同”，即使它们是空的。我们可以通过创建一个*始终存在的特殊节点*来做到这一点，我们将其称为**哨兵节点**。哨兵节点将保存一个值，我们不会关心该值。

```java
public void addLast(int x) {
    size += 1;
    IntNode p = sentinel; //哨兵节点？
    while (p.next != null) {
        p = p.next;
    }

    p.next = new IntNode(x, null);
}
```

**哨兵节点**：一个特殊的节点，通常不包含有用的数据，但在数据结构中具有重要的作用。哨兵节点的主要目的是简化算法的实现并提高代码的效率。

- **简化边界条件**：哨兵节点可以用来消除在算法中处理边界条件的需要。它们可以作为链表头部或尾部的虚拟节点，用于处理插入、删除或搜索等操作。这使得代码更加简洁，减少了对特殊情况的处理。
- **提高性能**：哨兵节点可以减少代码中的条件判断，从而提高了算法的性能。例如，在双向链表中，使用哨兵节点可以使插入和删除操作变得更快，因为不需要检查头部或尾部是否为空。
- **统一接口**：哨兵节点可以使数据结构的接口更一致。无论是插入第一个元素还是插入后继元素，都可以使用相同的操作。
- **方便遍历**：在某些情况下，哨兵节点可以用于简化遍历操作。它们可以用作循环的起始和终止条件，使得遍历更加简单和可读。

### 不变量

具有哨兵节点的SLList（单链表）至少具有以下不变性：

1. 哨兵引用始终指向哨兵节点。
2. 前置项（如果存在）始终位于sentinel.next.item。
3. size变量始终是已添加的总项目数量。





## DLList（双链表）

前面介绍了单链表的一些特性，接下来是双链表。但是单链表只能往一个方向移动，并不能回溯前面的节点，所以有了双链表。

前面说的`addLast(int x)`方法是很慢的，因为要从链表的开头走完整个链表，复杂度为`n(O)`，因此，我们尝试去添加一个尾节点来进行加速：

```java
public class SLList {
    private IntNode sentinel; //哨兵节点，而非first,这是为了保持统一处理。
    private IntNode last;
    private int size;    

    public void addLast(int x) {
        last.next = new IntNode(x, null);
        last = last.next;
        size += 1;
    }
    ...
}
```

